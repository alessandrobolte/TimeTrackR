<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Zeitmanagement ‚Äî LemGOesHANA</title>
<link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üïí</text></svg>">
<style>
  :root{
    --bg:#f3f4f6;
    --panel:#ffffff;
    --text:#0b1220;
    --muted:#425066;
    --accent1:#28a745;
    --accent2:#3b82f6;
    --radius:12px;
    --shadow: 0 8px 24px rgba(15,23,42,0.06);
  }
  :root.dark{
    --bg:#0b0b0c;
    --panel:#0f1112;
    --text:#e8e8e8;
    --muted:#9aa0a6;
    --accent1:#ff4d4f;
    --accent2:#ff902b;
    --shadow: 0 8px 28px rgba(0,0,0,0.6);
  }

  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;
    background:var(--bg);color:var(--text);-webkit-font-smoothing:antialiased;padding:20px;display:flex;justify-content:center;
  }

  .app{width:100%;max-width:1100px;}
  header{display:flex;align-items:center;justify-content:space-between;margin-bottom:14px}
  h1{margin:0;font-size:1.6rem}
  .top-controls{display:flex;gap:10px;align-items:center}
  button{background:var(--panel);border:1px solid rgba(0,0,0,0.06);color:var(--text);padding:8px 12px;border-radius:10px;cursor:pointer;box-shadow:var(--shadow)}
  .small{padding:6px 10px;font-size:0.9rem}
  .ghost{background:transparent}
  .accent{background:linear-gradient(90deg,var(--accent1),var(--accent2));border:none;color:#fff}
  .danger{background:transparent;border:1px solid var(--accent1);color:var(--accent1)}

  .top{display:flex;gap:16px;align-items:flex-start}
  .cats-panel{flex:1;background:var(--panel);padding:16px;border-radius:var(--radius)}
  .timer-panel{width:360px;min-width:260px;background:var(--panel);padding:18px;border-radius:var(--radius);display:flex;flex-direction:column;align-items:center;gap:10px}

  .category-list{display:flex;flex-wrap:wrap;gap:10px;margin-top:12px}
  .category-card{padding:10px 12px;border-radius:10px;background:linear-gradient(90deg, rgba(0,0,0,0.02), transparent);display:flex;align-items:center;gap:12px;border:1px solid rgba(0,0,0,0.04)}
  .category-name{font-weight:700}
  .category-meta{font-size:0.85rem;color:var(--muted)}

  .time-big{font-size:2.2rem;font-weight:800}
  .timer-controls{display:flex;gap:8px;margin-top:8px}
  select,input{
  padding:8px;
  border-radius:8px;
  border:1px solid rgba(0,0,0,0.15);
  background:var(--panel);   /* ‚úÖ Fix */
  color:var(--text);
}
  input[type="number"]{width:80px}

  .actions-row{display:flex;gap:8px;align-items:center;margin-top:12px}
  .centered{display:flex;justify-content:center}

  .stats-panel{background:var(--panel);padding:14px;border-radius:var(--radius);margin-top:14px}
  .stats-header{display:flex;align-items:center;justify-content:space-between}
  .toggle-details{cursor:pointer;color:var(--muted);font-size:0.95rem}
  .charts{display:grid;grid-template-columns:1fr 420px;gap:12px;margin-top:12px}
  canvas{background:linear-gradient(180deg, rgba(0,0,0,0.02), transparent);border-radius:10px;padding:8px}
  .absence-calendar button.small.ghost {
  padding: 4px 8px;
  border-radius: 8px;
  border: 1px solid rgba(0,0,0,0.1);
}

  table{width:100%;border-collapse:collapse;margin-top:10px}
  th,td{padding:8px 6px;text-align:left;border-bottom:1px dashed rgba(0,0,0,0.06)}
  .sessions-list{max-height:220px;overflow:auto}

  .modal-backdrop{position:fixed;inset:0;background:rgba(0,0,0,0.45);display:flex;align-items:center;justify-content:center;z-index:9999}
  .modal{background:var(--panel);padding:18px;border-radius:12px;min-width:320px;max-width:720px}
  .form-row{display:flex;gap:8px;margin-bottom:8px}
  label{font-size:0.9rem;color:var(--muted);min-width:120px;display:inline-block}

  @media (max-width:980px){ .charts{grid-template-columns:1fr} .timer-panel{width:100%} .top{flex-direction:column} }

  .tooltip{position:absolute;padding:6px 8px;border-radius:6px;background:var(--panel);border:1px solid rgba(0,0,0,0.06);pointer-events:none;font-size:0.9rem;z-index:10000}
  #toast{z-index:9999;backdrop-filter:blur(6px);}
  :root:not(.dark) #toast{background:#0077cc;color:white}
  .dark #toast{background:#ff6600;color:#fff}
</style>
</head>
<body>
  <div class="app" id="app">
    <header>
      <div>
        <h2 id="appTitle">TimeTrackR ‚Äì Deine pers√∂nliche Zeiterfassung f√ºr Projekte und Kategorien</h2>
        <div id="loading" style="display:none;color:var(--muted);font-size:0.9rem">‚è≥ Einloggen ... Lade Daten</div>
      </div>
      <div class="top-controls">
        <div id="greeting" style="font-weight:600;color:var(--muted)"></div>
        <button id="modeToggle" class="small" title="Theme wechseln">‚òÄÔ∏è</button>
        <button id="logoutBtn" class="small ghost" style="display:none">Ausloggen</button>
      </div>
    </header>

    <div id="mainContent">
      <!-- Content rendered by JS -->
    </div>

    <div id="modalRoot"></div>
  </div>

  <script>
    async function sha256Hex(str) {
  const enc = new TextEncoder().encode(str);
  const digest = await crypto.subtle.digest("SHA-256", enc);
  const bytes = new Uint8Array(digest);
  return Array.from(bytes).map(b => b.toString(16).padStart(2, "0")).join("");
}
    // ---------------------------
    // Simple IndexedDB wrapper (promisified)
    // ---------------------------
    function openDB(name, version=1){
      return new Promise((res, rej)=>{
        const r = indexedDB.open(name, version);
        r.onupgradeneeded = e => {
          const db = e.target.result;
          if(!db.objectStoreNames.contains('users')) db.createObjectStore('users',{keyPath:'username'});
          if(!db.objectStoreNames.contains('categories')) db.createObjectStore('categories',{keyPath:'id'});
          if(!db.objectStoreNames.contains('meta')) db.createObjectStore('meta',{keyPath:'k'});
        };
        r.onsuccess = e => res(e.target.result);
        r.onerror = e => rej(e.target.error);
      });
    }
    async function idbGet(db, store, key) {
  if (!db) db = await openDB('zm_db', 1); // üîß sicherstellen, dass DB offen ist
  return new Promise((res, rej) => {
    const tx = db.transaction(store, 'readonly');
    const os = tx.objectStore(store);
    const r = os.get(key);
    r.onsuccess = () => res(r.result);
    r.onerror = () => rej(r.error);
  });
}
    function idbPut(db, store, val){ return new Promise((res,rej)=>{ const tx=db.transaction(store,'readwrite'); const os=tx.objectStore(store); const r=os.put(val); r.onsuccess=()=>res(r.result); r.onerror=()=>rej(r.error); }); }
    function idbGetAll(db, store){ return new Promise((res,rej)=>{ const tx=db.transaction(store,'readonly'); const os=tx.objectStore(store); const r=os.getAll(); r.onsuccess=()=>res(r.result); r.onerror=()=>rej(r.error); }); }
    function idbDelete(db, store, key){ return new Promise((res,rej)=>{ const tx=db.transaction(store,'readwrite'); const os=tx.objectStore(store); const r=os.delete(key); r.onsuccess=()=>res(); r.onerror=()=>rej(r.error); }); }
    async function idbClear(db, store){ return new Promise((res,rej)=>{ const tx=db.transaction(store,'readwrite'); const os=tx.objectStore(store); const r=os.clear(); r.onsuccess=()=>res(); r.onerror=()=>rej(r.error); }); }
    // ---------------------------
// Cloudflare API: Session speichern / abrufen
// ---------------------------
async function saveSessionToCloud(session) {
  try {
    await fetch("https://timetrackr.alessandrobolte.workers.dev/api/saveSession", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(session),
    });
  } catch (err) {
    console.error("‚ùå Fehler beim Cloud-Speichern:", err);
  }
}

async function loadSessionsFromCloud(username) {
  try {
    const res = await fetch(
      `https://timetrackr.alessandrobolte.workers.dev/api/getSessions?username=${encodeURIComponent(username)}`
    );
    if (!res.ok) throw new Error(res.statusText);
    return await res.json();
  } catch (err) {
    console.error("‚ùå Fehler beim Cloud-Laden:", err);
    return [];
  }
}

    // ---------------------------
    // App Constants & initial data
    // ---------------------------
    const INIT_PW = 'Stadtwerke1';
    const USERS = [
      ['admin', INIT_PW, 'Projektleiter', 'Administrator'],
      ['alessandro', INIT_PW, 'Alessandro Bolte', 'User'],
      ['michael', INIT_PW, 'Michael Teuber', 'User'],
      ['dominik', INIT_PW, 'Dominik Schulte', 'User'],
      ['christiane', INIT_PW, 'Christiane Kuhlemann', 'User'],
      ['fabian', INIT_PW, 'Fabian Brinkmann', 'User'],
      ['kati', INIT_PW, 'Kati Kretzschmar', 'User'],
      ['denise', INIT_PW, 'Denise Carnovale', 'User'],
      ['philip', INIT_PW, 'Philip Rolf', 'User'],
      ['marcel', INIT_PW, 'Marcel Sander', 'User'],
      ['yannik', INIT_PW, 'Yannik Siebert', 'User']
    ];
    const NON_DELETABLE_CATEGORY_NAME = 'LemGOesHANA';
    
    let DB = null;
    let STATE = { currentUser: null };
    
    // ---------------------------
    // Utils
    // ---------------------------
    const uid = ()=> Math.random().toString(36).slice(2,9);
    const minutesToHuman = min => { const h = Math.floor(min/60); const m = Math.round(min%60); return `${h}h ${m}m`; };
    const msToHms = ms => { if(!isFinite(ms)) return '--:--:--'; const secs=Math.floor(ms/1000); const h=Math.floor(secs/3600), m=Math.floor((secs%3600)/60), s=secs%60; return `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`; };
    
    // ---------------------------
    // Initialization: DB and default data
    // ---------------------------
// ---------------------------
// Initialization: DB and default data
// ---------------------------
async function init() {
  DB = await openDB('zm_db', 1);

  // ü©∫ Sicherstellen, dass LemGOesHANA existiert (nur einmal pr√ºfen)
  try {
    const cats = await idbGetAll(DB, 'categories');
    let lem = cats.find(c => c.name.toLowerCase() === NON_DELETABLE_CATEGORY_NAME.toLowerCase());
    if (!lem) {
      lem = {
        id: uid(),
        name: NON_DELETABLE_CATEGORY_NAME,
        owner: 'system',
        system: true,
        sessions: []
      };
      await idbPut(DB, 'categories', lem);
      console.log('‚úÖ LemGOesHANA wurde neu angelegt');
    } else {
      // Repariere evtl. falsche Flags
      let changed = false;
      if (!lem.system) { lem.system = true; changed = true; }
      if (lem.owner !== 'system') { lem.owner = 'system'; changed = true; }
      if (changed) {
        await idbPut(DB, 'categories', lem);
        console.log('üîß LemGOesHANA repariert');
      }
    }
  } catch (err) {
    console.error('‚ùå Fehler beim LemGOesHANA-Check:', err);
  }

  // ensure users exist
  const existing = await idbGetAll(DB, 'users');
  if (!existing || existing.length === 0) {
    for (const u of USERS) {
      await idbPut(DB, 'users', {
        username: u[0],
        password: u[1],
        displayName: u[2],
        role: u[3],
        pwExpired: true
      });
    }
  }

  // theme
  const theme = localStorage.getItem('zm_theme') || 'light';
  document.documentElement.classList.toggle('dark', theme === 'dark');
  document.getElementById('modeToggle').textContent = theme === 'light' ? '‚òÄÔ∏è' : 'üåô';

  ensureToastStyles();
  bindUI();
  renderLogin();
}

    
    // ---------------------------
    // UI bindings and helpers
    // ---------------------------
    function setLoading(show, text=''){ const el=document.getElementById('loading'); if(show){ el.style.display='block'; el.textContent = text || '‚è≥ Einloggen ... Lade Daten'; } else el.style.display='none'; }
    function showToast(msg, ms=2200){
      let t=document.getElementById('toast');
      if(!t){
        t=document.createElement('div');
        t.id='toast';
        // baseline styles; theme colors kommen aus CSS-Variablen
        t.style.position='fixed';
        t.style.top='16px';
        t.style.right='16px';
        t.style.maxWidth='280px';
        t.style.padding='10px 12px';
        t.style.borderRadius='10px';
        t.style.boxShadow='var(--shadow)';
        t.style.fontSize='0.95rem';
        t.style.display='none';
        t.style.zIndex='99999';
        document.body.appendChild(t);
      }
      t.textContent=msg;
      t.style.display='block';
      t.style.opacity='1';
      setTimeout(()=>{
        t.style.opacity='0';
        setTimeout(()=>t.style.display='none',400);
      },ms);
    }
    function ensureToastStyles(){
      // Nothing else to do (colors kommen aus globalem CSS),
      // aber falls Styles √ºberschrieben waren, setzen wir sie hier erneut.
      const t=document.getElementById('toast');
      if(t){
        t.style.position='fixed';
        t.style.top='16px';
        t.style.right='16px';
        t.style.maxWidth='280px';
        t.style.padding='10px 12px';
        t.style.borderRadius='10px';
        t.style.boxShadow='var(--shadow)';
        t.style.zIndex='99999';
      }
    }
    
    function bindUI(){
      document.getElementById('modeToggle').addEventListener('click', ()=>{
        const isDark = document.documentElement.classList.toggle('dark');
        localStorage.setItem('zm_theme', isDark? 'dark':'light');
        document.getElementById('modeToggle').textContent = isDark? 'üåô':'‚òÄÔ∏è';
      });
      document.getElementById('logoutBtn').addEventListener('click', async ()=>{
        STATE.currentUser = null;
        document.getElementById('greeting').textContent='';
        renderLogin();
      });
    }
    
    // ---------------------------
    // Login Flow (client-side login for demo)
    // ---------------------------
    async function renderLogin(){
      const main = document.getElementById('mainContent');
      main.innerHTML = `
        <div style="display:flex;align-items:center;justify-content:center;min-height:420px">
          <div style="width:380px;padding:18px;border-radius:12px;background:var(--panel);box-shadow:var(--shadow)">
            <h2 style="margin-top:0">Login üîê</h2>
            <div style="margin-bottom:8px;color:var(--muted)">Bitte melde dich mit deinem Benutzernamen an.</div>
            <div style="display:flex;flex-direction:column;gap:8px">
              <input id="loginUser" placeholder="Benutzername" autofocus />
              <input id="loginPw" placeholder="Passwort" type="password" />
              <div style="display:flex;gap:8px;justify-content:flex-end">
                <button id="loginBtn" class="accent">Einloggen</button>
              </div>
            </div>
            <div style="margin-top:10px;font-size:0.9rem;color:var(--muted)"></div>
          </div>
        </div>
      `;
    
      document.getElementById('loginBtn').addEventListener('click', async () => {
  const u = document.getElementById('loginUser').value.trim();
  const p = document.getElementById('loginPw').value;
  if (!u || !p) { alert('Bitte Benutzername und Passwort eingeben.'); return; }
  setLoading(true, '‚è≥ Einloggen ... Lade Daten');

  try {
    // 1) Cloud abfragen
    let cloudUser = null;
    try {
      const r = await fetch(`https://timetrackr.alessandrobolte.workers.dev/api/getUser?username=${encodeURIComponent(u)}`);
      if (r.ok) {
        const j = await r.json();
        if (j.ok && j.user) cloudUser = j.user;
      }
    } catch { /* offline? Ignorieren -> fallback */ }

    if (cloudUser) {
      // 2) Passwort lokal hashen und gegen KV-Hash vergleichen
      const givenHash = await sha256Hex(p);
      if (givenHash !== cloudUser.passwordHash) {
        setLoading(false);
        alert('Falsches Passwort.');
        return;
      }

      // 3) Lokalen User synchron halten (f√ºr Rolle/Name etc.)
      let local = await idbGet(DB, 'users', u);
      if (!local) {
        local = {
          username: cloudUser.username,
          password: '***cloud***',     // nicht verwendet
          displayName: cloudUser.displayName || cloudUser.username,
          role: cloudUser.role || 'User',
          pwExpired: !!cloudUser.pwExpired
        };
      } else {
        local.displayName = cloudUser.displayName || local.displayName;
        local.role = cloudUser.role || local.role;
        local.pwExpired = !!cloudUser.pwExpired;
      }
      await idbPut(DB, 'users', local);

      STATE.currentUser = local.username;
      localStorage.setItem('zm_lastUser', local.username);
      document.getElementById('greeting').textContent = 'Hallo ' + local.displayName + ' üëã';
      document.getElementById('logoutBtn').style.display = 'inline-block';
      setLoading(false);
      // üïí "Zuletzt online" speichern (Cloud-User)
local.lastOnline = Date.now();
await idbPut(DB, 'users', local);


      const gm = openModal(`<h3>Hallo ${local.displayName} üëã</h3><div style="margin-top:8px;color:var(--muted)">Du wirst jetzt weitergeleitet ‚Ä¶</div>`);
      setTimeout(() => { closeModal(); if (local.pwExpired) { renderChangePassword(true); } else { renderDashboard(); } }, 900);
      return;
    }

    // 4) Fallback: Kein KV-User -> lokaler Demo-User
    const user = await idbGet(DB, 'users', u);
    if (!user) { setLoading(false); alert('Benutzer nicht gefunden.'); return; }
    if (user.password !== p) { setLoading(false); alert('Falsches Passwort.'); return; }

    STATE.currentUser = user.username;
    localStorage.setItem('zm_lastUser', user.username);
    document.getElementById('greeting').textContent = 'Hallo ' + user.displayName + ' üëã';
    document.getElementById('logoutBtn').style.display = 'inline-block';
    setLoading(false);
    // üïí "Zuletzt online" speichern (Lokaler User)
user.lastOnline = Date.now();
await idbPut(DB, 'users', user);

    const gm = openModal(`<h3>Hallo ${user.displayName} üëã</h3><div style="margin-top:8px;color:var(--muted)">Du wirst jetzt weitergeleitet ‚Ä¶</div>`);
    setTimeout(() => { closeModal(); if (user.pwExpired) { renderChangePassword(true); } else { renderDashboard(); } }, 900);

  } catch (e) {
    setLoading(false);
    alert('Fehler beim Einloggen');
  }
});
    }
    
    // ---------------------------
    // Password change (forced on first login)
    // ---------------------------
    async function renderChangePassword(forced=false){
      const main = document.getElementById('mainContent');
      main.innerHTML = `
        <div style="display:flex;align-items:center;justify-content:center;min-height:420px">
          <div style="width:420px;padding:18px;border-radius:12px;background:var(--panel);box-shadow:var(--shadow)">
            <h2>Passwort √§ndern üîë</h2>
            <div style="margin-bottom:8px;color:var(--muted)">Bitte w√§hle ein neues Passwort (mind. 6 Zeichen).</div>
            <div style="display:flex;flex-direction:column;gap:8px">
              <input id="newPw" placeholder="Neues Passwort" type="password" />
              <input id="newPw2" placeholder="Neues Passwort wiederholen" type="password" />
              <div style="display:flex;gap:8px;justify-content:flex-end">
                <button id="savePwBtn" class="accent">Speichern</button>
              </div>
            </div>
          </div>
        </div>
      `;
      document.getElementById('savePwBtn').addEventListener('click', async () => {
  const a = document.getElementById('newPw').value;
  const b = document.getElementById('newPw2').value;
  if (!a || a.length < 6) { alert('Passwort zu kurz (mind. 6 Zeichen).'); return; }
  if (a !== b) { alert('Passw√∂rter stimmen nicht √ºberein.'); return; }

  const username = STATE.currentUser;
  const user = await idbGet(DB,'users', username);
  if (!user) { alert('Benutzer unbekannt.'); return; }

  // 1) Lokal weiter pflegen (f√ºr Offline-Fall/Nur-Demo-User)
  user.password = a;           // nur f√ºr lokale Accounts relevant
  user.pwExpired = false;
  await idbPut(DB,'users', user);

  // 2) In die Cloud synchronisieren (gehashter Passwortwert)
  try {
    const passwordHash = await sha256Hex(a);
    await fetch("https://timetrackr.alessandrobolte.workers.dev/api/saveUser", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        username,
        passwordHash,
        displayName: user.displayName,
        role: user.role,
        pwExpired: false
      })
    });
  } catch (err) {
    console.warn("‚ö†Ô∏è Konnte gehashtes Passwort nicht an die Cloud senden:", err);
    // kein Abbruch ‚Äì lokal ist das Passwort korrekt ge√§ndert
  }

  showToast('Passwort ge√§ndert ‚úÖ');
  renderDashboard();
});

    }
    
// ---------------------------
// Sichtbare Kategorien (inkl. LemGOesHANA f√ºr alle User)
// ---------------------------
async function getVisibleCategories() {
  const user = await idbGet(DB, 'users', STATE.currentUser);
  if (!user) return [];
  const isAdmin = user.role === 'Administrator';
  const cats = await idbGetAll(DB, 'categories');

  if (isAdmin) {
    // Admin sieht nur LemGOesHANA
    return cats.filter(c => c.system && c.name === NON_DELETABLE_CATEGORY_NAME);
  } else {
    // User sieht eigene Kategorien + LemGOesHANA
    return cats.filter(c =>
      c.owner === STATE.currentUser ||
      (c.system && c.name === NON_DELETABLE_CATEGORY_NAME)
    );
  }
}

    function filterSessionsForViewer(cat, sessions){
      if(!sessions) return [];
      // Admin: alle Sessions in LemGOesHANA
      // User: nur eigene Sessions (auch in LemGOesHANA)
      const isAdminPromise = idbGet(DB,'users',STATE.currentUser).then(u=> u && u.role==='Administrator');
      // return a proxy promise consumer uses with await
      return (async()=>{
        const isAdmin = await isAdminPromise;
        if(isAdmin) return cat.system ? sessions.slice() : []; // Admin hat nur LemGOesHANA im Blick
        return sessions.filter(s=> (s && s.username === STATE.currentUser));
      })();
    }
    // ---------------------------
// Cloudflare ‚Üí Lokaler Sync (beim Login oder Dashboard-Start)
// ---------------------------
async function syncFromCloud() {
  if (!STATE.currentUser) return;
  try {
    const res = await fetch(`https://timetrackr.alessandrobolte.workers.dev/api/getSessions?username=${STATE.currentUser}`);
    if (!res.ok) throw new Error("Fehler beim Abruf der Cloud-Daten");
    const sessions = await res.json();
    if (!Array.isArray(sessions) || sessions.length === 0) return;

    console.log(`‚òÅÔ∏è ${sessions.length} Cloud-Sessions geladen`);

    // Kategorien aus DB laden
    const cats = await idbGetAll(DB, "categories");
    const catMap = new Map(cats.map(c => [c.name, c]));

    for (const s of sessions) {
      const catName = s.category || "Allgemein";
      let cat = catMap.get(catName);

      // Falls Kategorie lokal nicht existiert ‚Üí erstellen
      if (!cat) {
        cat = { id: uid(), name: catName, owner: STATE.currentUser, sessions: [] };
        await idbPut(DB, "categories", cat);
        catMap.set(catName, cat);
      }

      // Pr√ºfen, ob Session schon lokal existiert
      const exists = (cat.sessions || []).some(x => x.id === s.id);
      if (!exists) {
        cat.sessions = cat.sessions || [];
        cat.sessions.push({
          id: s.id,
          username: STATE.currentUser,
          durationMin: s.durationMin,
          note: s.note || ""
        });
        await idbPut(DB, "categories", cat);
      }
    }

    console.log("‚úÖ Cloud-Sessions lokal synchronisiert");
  } catch (err) {
    console.warn("‚ö†Ô∏è Cloud-Sync fehlgeschlagen:", err);
  }
}

    // ---------------------------
    // Dashboard (User + Admin variations)
    // ---------------------------
    async function renderDashboard(){
      await syncFromCloud();
      const user = await idbGet(DB,'users',STATE.currentUser);
      if(!user) return renderLogin();
      const isAdmin = user.role === 'Administrator';
      const catsVisible = await getVisibleCategories();
    
      const main = document.getElementById('mainContent');
      main.innerHTML = `
        <div class="top">
          <section class="cats-panel" aria-labelledby="catsTitle">
            <div style="display:flex;justify-content:space-between;align-items:center">
              <div style="display:flex;gap:8px;align-items:center">
                ${isAdmin ? '' : '<button id="addCategoryBtn" class="accent small">Kategorie hinzuf√ºgen</button>'}
                ${isAdmin ? '' : '<button id="delModeBtn" class="ghost small" aria-pressed="false">L√∂schen</button>'}
              </div>
              <div style="text-align:right"><div id="catsTitle" style="font-size:0.9rem;color:var(--muted)">Kategorien</div></div>
            </div>
            <div class="category-list" id="categoryList"></div>
            <div class="actions-row" style="margin-top:12px">
              <input type="file" id="importFile" accept=".csv,text/csv" style="display:none" />
              <button id="exportBtn" class="small ghost">Export (CSV)</button>
              <button id="importBtn" class="small ghost">Import</button>
              <button id="refreshBtn" class="small ghost">üîÑ Refresh</button>
            </div>
            <div class="centered" style="margin-top:10px"><button id="forgotBtn" class="accent">Zeit stoppen vergessen?</button></div>
            <div class="centered" style="margin-top:6px"><button id="absenceBtn" class="small ghost">Meine Abwesenheiten</button></div>

          </section>
    
          <aside class="timer-panel" aria-label="Timer Panel">
            <div style="font-size:0.9rem;color:var(--muted)">Aktueller Timer</div>
            <div class="time-big" id="activeTimerDisplay">--:--:--</div>
            <div style="width:100%;display:flex;gap:8px;align-items:center">
              <label for="activeCategorySelect" style="min-width:110px;color:var(--muted)">Kategorie</label>
              <select id="activeCategorySelect" aria-label="Aktive Kategorie" style="flex:1"></select>
            </div>
            <div class="timer-controls" style="width:100%;justify-content:center">
              <button id="startBtn" class="small">Start</button>
              <button id="stopBtn" class="small">Stop</button>
            </div>
            <div style="font-size:0.9rem;color:var(--muted);text-align:center;margin-top:6px">Timer l√§uft auch nach Reload weiter</div>
            <button id="undockBtn" class="small ghost" style="margin-top:6px">Timer abdocken</button>
          </aside>
        </div>
    
        <section class="stats-panel" id="statsPanel">
          <div class="stats-header">
            <div style="display:flex;gap:10px;align-items:center">
              <div id="statsTitle" style="font-weight:700">Statistiken</div>
              <div id="rangeButtons" style="display:flex;gap:6px">
                <button class="small" data-range="7">Letzte 7 Tage</button>
                <button class="small" data-range="14">Letzte 14 Tage</button>
                <button class="small" data-range="30">30 Tage</button>
                <button class="small" data-range="all">Gesamt</button>
              </div>
            </div>
            <div class="toggle-details" id="toggleStats">Ausklappen ‚ñæ</div>
          </div>
    
          <div id="statsContent" style="display:none;margin-top:10px">
            <div style="display:flex;justify-content:space-between;gap:12px;align-items:flex-start;flex-wrap:wrap">
              <div style="flex:1;min-width:320px">
                <table id="statsTable"><thead><tr><th>Kategorie</th><th>Gesamt</th><th>√ò / Tag</th><th>/ Woche</th><th>Sessions</th></tr></thead><tbody></tbody></table>
              </div>
              <div style="width:420px"><canvas id="barChart" width="420" height="220" role="img"></canvas></div>
            </div>
    
            <div style="margin-top:12px">
              <div style="font-weight:700;margin-bottom:8px">Verlauf</div>
              <canvas id="lineChart" width="980" height="240" style="width:100%"></canvas>
            </div>
    
            <div style="margin-top:12px">
              <div style="font-weight:700;margin-bottom:8px">Sessions (Details)</div>
              <div class="sessions-list"><table id="sessionsTable"><thead><tr><th>Benutzer</th><th>Kategorie</th><th>Dauer</th><th>Notiz</th>${isAdmin ? '' : '<th>Aktion</th>'}</tr></thead><tbody></tbody></table></div>
            </div>
          </div>
        </section>
      `;
    
      // wire up actions
      if(!isAdmin){
        document.getElementById('addCategoryBtn').addEventListener('click', async ()=>{
          const name = prompt('Name der Kategorie:'); if(!name) return;
          if(name.trim().toLowerCase() === NON_DELETABLE_CATEGORY_NAME.toLowerCase()){ alert('Diese Kategorie ist reserviert.'); return; }
          const existing = await idbGetAll(DB,'categories');
          if(existing.some(c=> c.owner===STATE.currentUser && c.name.toLowerCase()===name.toLowerCase())){ alert('Kategorie existiert bereits.'); return; }
          const id = uid(); await idbPut(DB,'categories',{id,name,owner:STATE.currentUser,system:false,sessions:[]}); renderDashboard();
        });
    
        document.getElementById('delModeBtn').addEventListener('click', ()=>{
          const btn=document.getElementById('delModeBtn');
          const pressed = btn.getAttribute('aria-pressed')==='true';
          btn.setAttribute('aria-pressed', String(!pressed));
          renderCategoryList(); // re-render with delete buttons
        });
      }
    
      document.getElementById('exportBtn').addEventListener('click', exportCSV);
      document.getElementById('importBtn').addEventListener('click', ()=> document.getElementById('importFile').click());
      document.getElementById('importFile').addEventListener('change', async e=>{
        const f=e.target.files[0]; if(!f) return; const txt=await f.text(); parseImportCSV(txt); e.target.value='';
      });
      
      document.getElementById('refreshBtn').addEventListener('click', ()=>{ renderDashboard(); showToast('Daten neu geladen ‚úÖ'); });
      document.getElementById('forgotBtn').addEventListener('click', openManualModal);
      document.getElementById('absenceBtn').addEventListener('click', openAbsenceModal);

    
      // timer bindings
      document.getElementById('startBtn').addEventListener('click', startTimer);
      document.getElementById('stopBtn').addEventListener('click', stopTimer);
      document.getElementById('undockBtn').addEventListener('click', openMiniTimerWindow);
    
      // stats toggle
      document.getElementById('toggleStats').addEventListener('click', ()=>{
        const cont = document.getElementById('statsContent');
        const open = cont.style.display==='block';
        cont.style.display = open? 'none':'block';
        document.getElementById('toggleStats').textContent = open? 'Ausklappen ‚ñæ':'Einklappen ‚ñ¥';
        drawBarChart(); drawLineChart();
      });
    
      // render lists and stats
      await renderCategoryList();
      renderStats();
      if (isAdmin) {
  const statsPanel = document.getElementById('statsPanel');
  if (statsPanel) {
    const absHTML = await renderAbsencePanel();
    const div = document.createElement('div');
    div.innerHTML = absHTML;
    statsPanel.appendChild(div);

    const toggle = div.querySelector('#toggleAbsences');
    toggle.addEventListener('click', () => {
      const cont = div.querySelector('#absencesContent');
      const open = cont.style.display === 'block';
      cont.style.display = open ? 'none' : 'block';
      toggle.textContent = open ? 'Abwesenheiten ‚ñæ' : 'Abwesenheiten ‚ñ¥';
    });
  }
}

      // greeting
      document.getElementById('greeting').textContent = 'Hallo ' + user.displayName ;
// ---------------------------
// Adminpanel mit Userverwaltung (Dropdown + Buttons)
// ---------------------------
if (isAdmin) {
  const catsPanel = document.querySelector('.cats-panel');
  if (catsPanel) {
    const panel = document.createElement('div');
    panel.style.marginTop = '12px';
    panel.innerHTML = `
      <div style="font-size:0.9rem;color:var(--muted)">Admin-Funktionen:</div>
      <button id="adminViewBtn" class="small accent" style="margin-top:6px">LemGOesHANA ansehen</button>
      <hr style="margin:10px 0;border:none;border-top:1px solid rgba(0,0,0,0.1)">
      <div style="font-size:0.9rem;color:var(--muted);margin-bottom:6px">Benutzerverwaltung:</div>
      <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
        <select id="userSelect" class="small" style="flex:1;min-width:140px"></select>
        <button id="resetUserPwBtn" class="small ghost">üîÅ Passwort zur√ºcksetzen</button>
        <button id="addUserBtn" class="small ghost">‚ûï Benutzer hinzuf√ºgen</button>
      </div>
    `;
    catsPanel.appendChild(panel);

    document.getElementById('adminViewBtn').addEventListener('click', () => showAdminView());
    document.getElementById('resetUserPwBtn').addEventListener('click', async () => {
      const sel = document.getElementById('userSelect');
      const name = sel.value;
      if (name) await resetUserPassword(name);
    });
    document.getElementById('addUserBtn').addEventListener('click', addNewUser);

    // Nach dem Rendern: Benutzerliste f√ºllen
    populateUserDropdown();
  }
}



    }
    
// ---------------------------
// Abwesenheiten ‚Äì Verwaltung & Anzeige
// ---------------------------

// User kann eigene Abwesenheiten verwalten
async function openAbsenceModal() {
  const user = await idbGet(DB, 'users', STATE.currentUser);
  if (!user) return;

  user.absences = user.absences || [];

  const list = user.absences
    .map((a, i) => `<tr>
      <td>${a.from}</td>
      <td>${a.to}</td>
      <td>${escapeHtml(a.note || '')}</td>
      <td><button class="small danger" data-idx="${i}">L√∂schen</button></td>
    </tr>`)
    .join('') || `<tr><td colspan="4" style="color:var(--muted);text-align:center">Keine Abwesenheiten</td></tr>`;

  const modal = openModal(`
    <h3>Meine Abwesenheiten üóìÔ∏è</h3>
    <div style="margin-bottom:8px">
      <label>Von:</label> <input id="absFrom" type="date">
      <label>Bis:</label> <input id="absTo" type="date">
      <label>Notiz:</label> <input id="absNote" placeholder="optional">
      <button id="addAbsBtn" class="small accent">Hinzuf√ºgen</button>
    </div>
    <table style="width:100%;margin-top:10px">
      <thead><tr><th>Von</th><th>Bis</th><th>Notiz</th><th>Aktion</th></tr></thead>
      <tbody id="absList">${list}</tbody>
    </table>
  `);

  // ‚ûï Hinzuf√ºgen
  modal.querySelector('#addAbsBtn').onclick = async () => {
    const from = modal.querySelector('#absFrom').value;
    const to = modal.querySelector('#absTo').value;
    const note = modal.querySelector('#absNote').value;
    if (!from || !to) return alert('Bitte Zeitraum ausw√§hlen.');
    user.absences.push({ from, to, note });
    await idbPut(DB, 'users', user);
    showToast('Abwesenheit hinzugef√ºgt ‚úÖ');
    closeModal();
    openAbsenceModal();
  };

  // ‚ùå L√∂schen
  modal.querySelectorAll('button[data-idx]').forEach(btn => {
    btn.onclick = async () => {
      const idx = parseInt(btn.dataset.idx, 10);
      user.absences.splice(idx, 1);
      await idbPut(DB, 'users', user);
      showToast('Abwesenheit gel√∂scht');
      closeModal();
      openAbsenceModal();
    };
  });
}

// Admin sieht alle Abwesenheiten
async function renderAbsencePanel() {
  const users = await idbGetAll(DB, 'users');
  if (!users || users.length === 0) return '';

  // Nur k√ºnftige Abwesenheiten
  const now = new Date().toISOString().slice(0,10);
  const rows = users
    .flatMap(u =>
      (u.absences || [])
        .filter(a => a.to >= now)
        .map(a => ({
          name: u.displayName,
          from: a.from,
          to: a.to,
          note: a.note || ''
        }))
    )
    .sort((a,b) => a.from.localeCompare(b.from));

  const tr = rows.map(r =>
    `<tr>
      <td>${escapeHtml(r.name)}</td>
      <td>${r.from}</td>
      <td>${r.to}</td>
      <td>${escapeHtml(r.note)}</td>
    </tr>`
  ).join('') || `<tr><td colspan="4" style="text-align:center;color:var(--muted)">Keine kommenden Abwesenheiten</td></tr>`;

  // Zuletzt online-Spalte
  const lastOnline = users
    .map(u => `<tr>
      <td>${escapeHtml(u.displayName)}</td>
      <td>${u.lastOnline ? new Date(u.lastOnline).toLocaleString('de-DE') : '-'}</td>
    </tr>`)
    .join('');

 // Kalenderdaten vorbereiten
const calendarHTML = renderAbsenceCalendar(rows);

return `
  <div style="margin-top:16px">
    <div class="toggle-details" id="toggleAbsences">Abwesenheiten ‚ñæ</div>
    <div id="absencesContent" style="display:none;margin-top:8px">
      <div style="font-weight:600;margin-bottom:6px">Kommende Abwesenheiten</div>
      <table style="width:100%;margin-bottom:14px">
        <thead><tr><th>Benutzer</th><th>Von</th><th>Bis</th><th>Notiz</th></tr></thead>
        <tbody>${tr}</tbody>
      </table>
      <div style="font-weight:600;margin-bottom:6px">Zuletzt online</div>
      <table style="width:100%;margin-bottom:14px">
        <thead><tr><th>Benutzer</th><th>Letzter Login</th></tr></thead>
        <tbody>${lastOnline}</tbody>
      </table>
      <div style="font-weight:600;margin-bottom:6px">Monatskalender</div>
      ${calendarHTML}
    </div>
  </div>
`;

}
// ---------------------------
// Monatskalender mit Navigation (Admin)
// ---------------------------
function renderAbsenceCalendar(absences) {
  // Wrapper erzeugen
  const container = document.createElement('div');
  container.className = 'absence-calendar';
  container.dataset.year = new Date().getFullYear();
  container.dataset.month = new Date().getMonth();

  function drawCalendar(year, month) {
    const firstDay = new Date(year, month, 1);
    const lastDay = new Date(year, month + 1, 0);
    const daysInMonth = lastDay.getDate();
    const today = new Date();

    // Abwesenheiten-Mapping
    const map = {};
    absences.forEach(a => {
      const from = new Date(a.from);
      const to = new Date(a.to);
      for (let d = new Date(from); d <= to; d.setDate(d.getDate() + 1)) {
        const key = d.toISOString().slice(0, 10);
        if (!map[key]) map[key] = [];
        map[key].push(a.name);
      }
    });

    const monthName = new Date(year, month, 1).toLocaleString('de-DE', {
      month: 'long',
      year: 'numeric'
    });
    const weekdays = ['Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa', 'So'];
    const startOffset = (firstDay.getDay() + 6) % 7;

    // Header mit Navigation
    let html = `
      <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:4px">
        <button id="prevMonth" class="small ghost">‚Üê</button>
        <div style="font-weight:600">${monthName}</div>
        <button id="nextMonth" class="small ghost">‚Üí</button>
      </div>
      <div style="display:grid;grid-template-columns:repeat(7,1fr);gap:4px;font-size:0.8rem;text-align:center;color:var(--muted);margin-bottom:4px">
        ${weekdays.map(w => `<div>${w}</div>`).join('')}
      </div>
      <div class="calendar-grid" style="display:grid;grid-template-columns:repeat(7,1fr);gap:4px">
    `;

    for (let i = 0; i < startOffset; i++) html += `<div></div>`;

    for (let d = 1; d <= daysInMonth; d++) {
      const date = new Date(year, month, d);
      const dateStr = date.toISOString().slice(0, 10);
      const names = map[dateStr];
      const hasAbs = !!names;
      const bg = hasAbs ? 'rgba(255,99,71,0.15)' : 'var(--panel)';
      const border = hasAbs
        ? '1px solid rgba(255,99,71,0.4)'
        : '1px solid rgba(0,0,0,0.05)';
      const tooltip = hasAbs ? names.join(', ') : '';
      const highlight =
        date.toDateString() === today.toDateString()
          ? 'outline:1px solid var(--accent2);'
          : '';

      html += `
        <div title="${escapeHtml(tooltip)}"
             style="background:${bg};border:${border};border-radius:8px;padding:6px;min-height:36px;position:relative;${highlight}">
          <div style="font-size:0.9rem">${d}</div>
          ${
            hasAbs
              ? `<div style="position:absolute;bottom:4px;left:50%;transform:translateX(-50%);width:6px;height:6px;background:tomato;border-radius:50%"></div>`
              : ''
          }
        </div>`;
    }

    html += `</div>`;
    container.innerHTML = html;

    // Navigation ankoppeln
    container.querySelector('#prevMonth').onclick = () => {
      let y = parseInt(container.dataset.year);
      let m = parseInt(container.dataset.month) - 1;
      if (m < 0) { m = 11; y--; }
      container.dataset.year = y;
      container.dataset.month = m;
      drawCalendar(y, m);
    };

    container.querySelector('#nextMonth').onclick = () => {
      let y = parseInt(container.dataset.year);
      let m = parseInt(container.dataset.month) + 1;
      if (m > 11) { m = 0; y++; }
      container.dataset.year = y;
      container.dataset.month = m;
      drawCalendar(y, m);
    };
  }

  drawCalendar(
    parseInt(container.dataset.year),
    parseInt(container.dataset.month)
  );

  return container.outerHTML;
}



    // ---------------------------
    // Categories list render (with visibility & delete rules)
    // ---------------------------
    async function renderCategoryList(){
      const user = await idbGet(DB,'users',STATE.currentUser);
      const isAdmin = user.role==='Administrator';
      const list = document.getElementById('categoryList');
      if(!list) return;
      list.innerHTML='';
      const sel = document.getElementById('activeCategorySelect');
      if(sel) sel.innerHTML='';
    
      const cats = await getVisibleCategories();
      const delMode = !isAdmin && document.getElementById('delModeBtn') && document.getElementById('delModeBtn').getAttribute('aria-pressed')==='true';
    
      for(const c of cats){
        const card = document.createElement('div'); card.className='category-card'; card.dataset.id=c.id;
        const left = document.createElement('div'); left.style.display='flex'; left.style.flexDirection='column';
        const name = document.createElement('div'); name.className='category-name'; name.textContent = c.name;
    
        // aggregate only visible sessions
        const visSessions = await filterSessionsForViewer(c, c.sessions||[]);
        const totalMin = visSessions.reduce((s,x)=> s + (x.durationMin || 0),0);
        const meta = document.createElement('div'); meta.className='category-meta';
        meta.textContent = `${totalMin} min ‚Ä¢ ${visSessions.length} sessions`;
    
        left.appendChild(name); left.appendChild(meta);
    
        const actions = document.createElement('div');
        actions.style.display='flex'; actions.style.alignItems='center'; actions.style.gap='8px';
    
        // Admin darf nichts starten/l√∂schen au√üerhalb LemGOesHANA; Start ist ok f√ºr alle sichtbaren
        const startBtnLocal = document.createElement('button');
        startBtnLocal.className='small'; startBtnLocal.textContent='Start';
        startBtnLocal.title='Timer f√ºr diese Kategorie starten';
        startBtnLocal.onclick = ()=>{ const select = document.getElementById('activeCategorySelect'); if(select){ select.value = c.id; } startTimer(); };
        actions.appendChild(startBtnLocal);
    
        const detailsBtn = document.createElement('button');
        detailsBtn.className='small ghost'; detailsBtn.textContent='Details';
        detailsBtn.onclick = ()=> showCategoryDetails(c.id);
        actions.appendChild(detailsBtn);
    
        if(delMode && !c.system && c.owner === STATE.currentUser){
          const del = document.createElement('button'); del.className='small danger'; del.textContent='L√∂schen';
          del.onclick = async ()=>{
            if(!confirm('Kategorie und alle Sitzungen l√∂schen?')) return;
            await idbDelete(DB,'categories',c.id);
            renderCategoryList(); showToast('Kategorie gel√∂scht');
          };
          actions.appendChild(del);
        }
    
        card.appendChild(left); card.appendChild(actions); list.appendChild(card);
    
        if(sel){
          const option = document.createElement('option'); option.value=c.id; option.textContent=c.name; sel.appendChild(option);
        }
      }
    }
    
    // ---------------------------
    // Timer logic
    // ---------------------------
    async function startTimer(){
      const sel = document.getElementById('activeCategorySelect');
      if(!sel || !sel.value){ alert('Bitte eine Kategorie anlegen und ausw√§hlen.'); return; }
      const active = JSON.parse(localStorage.getItem('zm_active') || 'null');
      if(active && active.username === STATE.currentUser){ alert('Es l√§uft bereits ein Timer.'); return; }
      const start = Date.now();
      const entry = { id: uid(), username: STATE.currentUser, start, durationMin:null, note:'', categoryId: sel.value };
      localStorage.setItem('zm_active', JSON.stringify(entry));
      showToast('Timer gestartet');
    }
    async function stopTimer(){
      const raw = localStorage.getItem('zm_active'); if(!raw){ alert('Kein laufender Timer.'); return; }
      const a = JSON.parse(raw);
      if(a.username !== STATE.currentUser){ alert('Ein anderer Benutzer hat einen laufenden Timer im Browser.'); return; }
      const durMin = Math.max(1, Math.round((Date.now() - a.start)/60000));
      // Session-Details wie im Dashboard
      const note = prompt('Kurze Beschreibung (optional):') || '';
    
      // store into category sessions (respect visibility rules by writing but UI filters on read)
      const cat = await idbGet(DB,'categories',a.categoryId);
      if(!cat){ alert('Kategorie nicht gefunden'); localStorage.removeItem('zm_active'); return; }
      // Admin soll nicht in fremden Kategorien schreiben k√∂nnen (nur LemGOesHANA)
      const user = await idbGet(DB,'users',STATE.currentUser);
      const isAdmin = user.role==='Administrator';
      if(isAdmin && !cat.system){
        alert('Admin kann nur in LemGOesHANA Zeiten erfassen.'); localStorage.removeItem('zm_active'); return;
      }
    
      cat.sessions = cat.sessions || [];
      cat.sessions.push({ id: a.id, username: a.username, durationMin: durMin, note });
      await idbPut(DB,'categories',cat);
      // ---- Cloudflare Worker Sync ----
try {
  await fetch("https://timetrackr.alessandrobolte.workers.dev/api/saveSession", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      username: STATE.currentUser,
      id: a.id,
      category: cat.name,
      durationMin: durMin,
      note: note || ''
    })
  });
  console.log("‚úÖ Session an Cloudflare gesendet");
} catch (err) {
  console.warn("‚ö†Ô∏è Konnte Session nicht an Worker senden:", err);
}
      localStorage.removeItem('zm_active');
      showToast('Zeit gestoppt ‚úì'); renderDashboard();
    }
    
    // keep display ticking
    setInterval(()=>{
      const raw=localStorage.getItem('zm_active'); const disp = document.getElementById('activeTimerDisplay');
      if(raw){
        try{
          const a=JSON.parse(raw); const ms = Date.now() - a.start;
          if(disp) disp.textContent = msToHms(ms);
        }catch(e){ if(disp) disp.textContent='--:--:--'; }
      } else if(disp) disp.textContent='--:--:--';
    },500);
    
    // ---------------------------
    // Manual entry modal (only duration)
    // ---------------------------
    async function openManualModal(){
      const catsVisible = await getVisibleCategories();
      // Nur in Kategorien erfassen, in die der User schreiben darf:
      // User: eigene + LemGOesHANA; Admin: nur LemGOesHANA
      const user = await idbGet(DB,'users',STATE.currentUser);
      const isAdmin = user.role==='Administrator';
      const catsWritable = catsVisible.filter(c => isAdmin ? c.system : true);
    
      const selOptions = catsWritable.map(c=>`<option value="${c.id}">${escapeHtml(c.name)}</option>`).join('');
      const modal = openModal(
        `<h3>Manuelles Nachtragen</h3>
         <div style="margin-top:8px"><label>Kategorie</label><select id="mcat">${selOptions}</select></div>
         <div style="margin-top:8px"><label>Dauer (Stunden)</label><input id="mhours" type="number" min="0" value="0" /> 
           <label style="margin-left:8px">Minuten</label><input id="mmins" type="number" min="0" max="59" value="30" /></div>
         <div style="display:flex;justify-content:flex-end;gap:8px;margin-top:10px">
           <button id="madd" class="accent">Hinzuf√ºgen</button><button id="mclose" class="small">Abbrechen</button>
         </div>`
      );
      modal.querySelector('#mclose').onclick = ()=> closeModal();
      modal.querySelector('#madd').onclick = async ()=>{
        const catId = modal.querySelector('#mcat').value; const h = parseInt(modal.querySelector('#mhours').value||'0',10); const m = parseInt(modal.querySelector('#mmins').value||'0',10);
        const dur = h*60 + m; if(dur<=0){ alert('Bitte Dauer angeben.'); return; }
        const note = prompt('Kurze Beschreibung (optional):') || '';
        const cat = await idbGet(DB,'categories',catId); cat.sessions = cat.sessions || [];
        cat.sessions.push({id: uid(), username: STATE.currentUser, durationMin: dur, note});
        await idbPut(DB,'categories',cat);
        closeModal(); showToast('Manuelle Zeit hinzugef√ºgt'); renderDashboard();
      };
    }
    
    // ---------------------------
    // Category details (visibility-safe)
    // ---------------------------
    async function showCategoryDetails(id) {
  const user = await idbGet(DB, 'users', STATE.currentUser);
  const isAdmin = user.role === 'Administrator';
  const c = await idbGet(DB, 'categories', id);
  if (!c) return;

  // üîí Sichtbarkeit pr√ºfen
  if (isAdmin) {
    // Admin darf nur LemGOesHANA ansehen
    if (!c.system || c.name !== NON_DELETABLE_CATEGORY_NAME) {
      alert('Admin darf nur LemGOesHANA ansehen.');
      return;
    }
  } else {
    // User darf eigene Kategorien und eigene Sessions in LemGOesHANA sehen
    const isOwn = c.owner === STATE.currentUser;
    const isLemGO = c.system && c.name === NON_DELETABLE_CATEGORY_NAME;
    if (!isOwn && !isLemGO) {
      alert('Nicht berechtigt.');
      return;
    }
  }

  // üî¢ Sessions + Usernamen vorbereiten
  const sessions = await filterSessionsForViewer(c, c.sessions || []);
  const allUsers = await idbGetAll(DB, 'users');
  const userMap = {};
  for (const u of allUsers) userMap[u.username] = u.displayName;

  const rows = sessions
    .map(
      (s, idx) => `
      <tr>
        <td>${escapeHtml(userMap[s.username] || s.username)}</td>
        <td>${minutesToHuman(s.durationMin || 0)}</td>
        <td contenteditable="${isAdmin ? 'false' : 'true'}" data-idx="${idx}">
          ${escapeHtml(s.note || '')}
        </td>
        ${isAdmin ? '' : `<td><button data-idx="${idx}" class="small">L√∂schen</button></td>`}
      </tr>`
    )
    .join('');

  const modal = openModal(`
    <h3>Details ‚Äî ${escapeHtml(c.name)}</h3>
    <div style="max-height:320px;overflow:auto;margin-top:8px">
      <table style='width:100%'>
        <thead>
          <tr>
            <th>Benutzer</th><th>Dauer</th><th>Notiz</th>${isAdmin ? '' : '<th>Aktion</th>'}
          </tr>
        </thead>
        <tbody>${rows}</tbody>
      </table>
    </div>
    <div style="font-size:0.8rem;color:var(--muted);margin-top:6px">
      ${
        isAdmin
          ? 'Admin-Ansicht: nur LemGOesHANA, alle Sessions sichtbar.'
          : 'Notizen sind editierbar. Eigene Sessions kannst du l√∂schen.'
      }
    </div>
  `);

  // üìù Notizen editieren
  if (!isAdmin) {
    modal.querySelectorAll('td[contenteditable="true"]').forEach(td => {
      td.addEventListener('blur', async () => {
        const idx = parseInt(td.dataset.idx, 10);
        const visible = await filterSessionsForViewer(c, c.sessions || []);
        const sVisible = visible[idx];
        if (!sVisible) return;
        const realIdx = (c.sessions || []).findIndex(r => r.id === sVisible.id);
        if (realIdx >= 0) {
          c.sessions[realIdx].note = td.textContent.trim();
          await idbPut(DB, 'categories', c);
        }
      });
    });

    // ‚ùå Eigene Sessions l√∂schen (lokal + Cloud)
    modal.querySelectorAll('button.small').forEach(b => {
      b.addEventListener('click', async () => {
        const idx = parseInt(b.dataset.idx, 10);
        const visible = await filterSessionsForViewer(c, c.sessions || []);
        const sVisible = visible[idx];
        if (!sVisible) return;

        if (sVisible.username !== STATE.currentUser) {
          alert('Du kannst nur eigene Sessions l√∂schen.');
          return;
        }

        if (!confirm('Session wirklich l√∂schen?')) return;

       // üîß ID-basiertes L√∂schen (auch f√ºr system-Kategorien wie LemGOesHANA)
let cat = await idbGet(DB, 'categories', c.id);
if (!cat || !cat.sessions) return;

// Falls system-Kategorie (z. B. LemGOesHANA), lokale Kopie aller Sessions laden
if (cat.system) {
  cat.sessions = (cat.sessions || []).filter(
    s => !(s.id === sVisible.id && s.username === STATE.currentUser)
  );
} else {
  cat.sessions = (cat.sessions || []).filter(s => s.id !== sVisible.id);
}

await idbPut(DB, 'categories', cat);


        // üå©Ô∏è Cloudflare-Sync: Session aus KV l√∂schen
        try {
          await fetch('https://timetrackr.alessandrobolte.workers.dev/api/deleteSession', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              username: STATE.currentUser,
              id: sVisible.id
            })
          });
          console.log('üóëÔ∏è Session auch in Cloud gel√∂scht');
        } catch (err) {
          console.warn('‚ö†Ô∏è Cloud-Delete fehlgeschlagen:', err);
        }

        // üîÅ UI aktualisieren
        showToast('Session gel√∂scht');
        closeModal();
        renderDashboard();
      });
    });
  }
}

    
    // ---------------------------
    // Admin view (keine separate UI mehr n√∂tig ‚Äì Details nutzt Regeln)
    // ---------------------------
    
    // ---------------------------
    // CSV Export/Import (export respektiert Sichtbarkeit beim Lesen)
    // ---------------------------
    async function exportCSV(){
      const cats = await getVisibleCategories();
      const rows=['category,categoryId,username,durationMin,note'];
      const allUsers = await idbGetAll(DB, 'users');
const userMap = {};
for (const u of allUsers) {
  userMap[u.username] = u.displayName;
}
      for(const c of cats){
        const vis = await filterSessionsForViewer(c, c.sessions||[]);
        vis.forEach(s=>{
  const name = userMap[s.username] || s.username;   // üîÅ Anzeigename statt Username
  rows.push(`${escapeCsv(c.name)},${c.id},${escapeCsv(name)},${s.durationMin||''},${escapeCsv(s.note||'')}`);
});
      }
      downloadBlob(rows.join('\n'),'zeitmanagement_export.csv');
    }
    // ---------------------------
// Admin Cloud View (LemGOesHANA aus Cloudflare)
// ---------------------------
async function showAdminView() {
  if (STATE.currentUser !== "admin") {
    alert("Nur Admins d√ºrfen diese Ansicht √∂ffnen.");
    return;
  }

  try {
    const res = await fetch("https://timetrackr.alessandrobolte.workers.dev/api/getSessions?username=all");
    if (!res.ok) throw new Error("Fehler beim Abrufen der Cloud-Daten");
    const allSessions = await res.json();

    if (!Array.isArray(allSessions) || allSessions.length === 0) {
      alert("Keine LemGOesHANA-Sessions in der Cloud gefunden.");
      return;
    }

    // Nur LemGOesHANA-Sessions
    const filtered = allSessions.filter(s => s.category === "LemGOesHANA");

    // Alle Benutzer ermitteln
    const users = [...new Set(filtered.map(s => s.username))].sort();
    users.unshift("Alle Benutzer");

    // Modal √∂ffnen mit Dropdown + Platz f√ºr Summenzeile
    openModal(`
      <h3>LemGOesHANA ‚Äî Cloud Sessions (Admin-Ansicht)</h3>
      <div style="margin-bottom:8px;display:flex;gap:8px;align-items:center">
        <label for="userFilter" style="color:var(--muted)">Benutzer:</label>
        <select id="userFilter" class="small">
          ${users.map(u => `<option value="${u}">${u}</option>`).join("")}
        </select>
        <button id="exportCloudBtn" class="small accent" style="margin-left:auto">Export (CSV)</button>
      </div>
      <div style="max-height:420px;overflow:auto;margin-top:8px">
        <table style="width:100%" id="adminSessionsTable">
          <thead>
            <tr><th>Benutzer</th><th>Dauer</th><th>Notiz</th><th>Zeitpunkt</th></tr>
          </thead>
          <tbody></tbody>
          <tfoot><tr id="summaryRow"><td colspan="4" style="text-align:right;color:var(--muted);font-weight:600;padding-top:6px"></td></tr></tfoot>
        </table>
      </div>
    `);

    const tbody = document.querySelector("#adminSessionsTable tbody");
    const summary = document.querySelector("#summaryRow td");
    const filterSelect = document.getElementById("userFilter");
// Nutzernamen auf Anzeigenamen mappen
const allUsers = await idbGetAll(DB, 'users');
const userMap = {};
for (const u of allUsers) userMap[u.username] = u.displayName;
    // Render-Funktion
    function renderTable(selectedUser) {
      const visible = filtered.filter(s => selectedUser === "Alle Benutzer" || s.username === selectedUser);
      let rows = visible
        .map(
          s => `
          <tr>
            <td>${escapeHtml(userMap[s.username] || s.username)}</td>
            <td>${minutesToHuman(s.durationMin || 0)}</td>
            <td>${escapeHtml(s.note || "")}</td>
            <td>${new Date(s.timestamp).toLocaleString("de-DE")}</td>
          </tr>`
        )
        .join("");

      if (!rows)
        rows = `<tr><td colspan="4" style="text-align:center;color:var(--muted)">Keine Eintr√§ge</td></tr>`;
      tbody.innerHTML = rows;

      // Summenzeile berechnen
      const totalMin = visible.reduce((sum, s) => sum + (s.durationMin || 0), 0);
      summary.textContent =
        totalMin > 0
          ? `Summe: ${minutesToHuman(totalMin)} (${totalMin} min)`
          : "Keine Zeiten vorhanden";
    }

    // Initial render
    renderTable("Alle Benutzer");

    // Filter-√Ñnderung
    filterSelect.addEventListener("change", e => renderTable(e.target.value));

    // CSV-Export
    document.getElementById("exportCloudBtn").addEventListener("click", () => {
      const selectedUser = filterSelect.value;
      const rows = filtered.filter(s => selectedUser === "Alle Benutzer" || s.username === selectedUser);
      const csv = ["username,durationMin,note,timestamp"];
      rows.forEach(s =>
        csv.push(`${escapeCsv(s.username)},${s.durationMin || 0},${escapeCsv(s.note || "")},${new Date(s.timestamp).toISOString()}`)
      );
      downloadBlob(csv.join("\n"), `lemgoeshana_${selectedUser === "Alle Benutzer" ? "all" : selectedUser}.csv`);
    });
  } catch (err) {
    console.error("‚ùå Fehler in showAdminView:", err);
    alert("Fehler beim Abrufen der Cloud-Daten.");
  }
}



    function downloadBlob(text, name){ const blob = new Blob([text],{type:'text/csv'}); const url = URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=name; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url); }
    function escapeCsv(t){ if(t==null) return ''; const s=String(t); if(s.includes(',')||s.includes('"')||s.includes('\n')) return '"' + s.replace(/"/g,'""') + '"'; return s; }
    function escapeHtml(s){ if(!s) return ''; return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }
    
    async function parseImportCSV(txt){
      const lines = txt.split(/\r?\n/).filter(Boolean); if(lines.length<=1){ alert('Keine Daten in CSV gefunden'); return; } lines.shift();
      const user = await idbGet(DB,'users',STATE.currentUser);
      const isAdmin = user.role==='Administrator';
      for(const line of lines){
        const parts = csvSplit(line); if(parts.length<5) continue;
        const catName = parts[0]; const catIdCsv = parts[1]; const username = parts[2] || STATE.currentUser; const dur = parts[3] ? parseInt(parts[3],10):0; const note = parts[4]||'';
        let cats = await idbGetAll(DB,'categories');
        let cat = cats.find(c=> c.id===catIdCsv) || cats.find(c=> c.name===catName);
        if(!cat){
          // Admin importiert nur nach LemGOesHANA; User importiert in eigene Kategorien
          if(isAdmin){
            cat = cats.find(c=> c.system) || {id:uid(),name:NON_DELETABLE_CATEGORY_NAME,owner:'system',system:true,sessions:[]};
          } else {
            cat = {id:uid(),name:catName,owner:STATE.currentUser,system:false,sessions:[]};
          }
          await idbPut(DB,'categories',cat);
        }
        // Schreibschutz: Admin nur in LemGOesHANA
        if(isAdmin && !cat.system) continue;
        cat.sessions = cat.sessions || [];
        cat.sessions.push({id: uid(), username: STATE.currentUser, durationMin: dur, note});
        await idbPut(DB,'categories',cat);
      }
      showToast('CSV importiert ‚úÖ'); renderDashboard();
    }
    function csvSplit(line){
      const out=[]; let cur=''; let inQ=false;
      for(let i=0;i<line.length;i++){
        const ch=line[i];
        if(inQ){
          if(ch==='"' && line[i+1]==='"'){ cur+='"'; i++; }
          else if(ch==='"'){ inQ=false; }
          else cur+=ch;
        } else {
          if(ch===','){ out.push(cur); cur=''; }
          else if(ch==='"'){ inQ=true; }
          else cur+=ch;
        }
      }
      out.push(cur); return out;
    }
    
    // ---------------------------
    // Stats & charts (respecting visibility)
    // ---------------------------
    let currentRange='7';
    async function renderStats(){
      const table = document.querySelector('#statsTable tbody'); const sessionsTable = document.querySelector('#sessionsTable tbody');
      if(!table) return;
    
      const cats = await getVisibleCategories();
      const agg = [];
      for(const c of cats){
        const vis = await filterSessionsForViewer(c, c.sessions||[]);
        let totalMin=0; let sessions=0;
        vis.forEach(s=>{ const dur = s.durationMin || 0; totalMin += dur; if(dur>0) sessions++; });
        // days/perDay/perWeek sind Sch√§tzwerte wie zuvor
        const days = 30; const perDay = totalMin/days; const perWeek = totalMin/7;
        agg.push({id:c.id,name:c.name,totalMin,perDay,perWeek,sessions});
      }
    
      table.innerHTML = '';
      agg.forEach(a=>{
        const tr=document.createElement('tr');
        tr.innerHTML = `<td>${escapeHtml(a.name)}</td><td>${minutesToHuman(Math.round(a.totalMin))}</td><td>${Math.round(a.perDay)} min</td><td>${Math.round(a.perWeek)} min</td><td>${a.sessions}</td>`;
        table.appendChild(tr);
      });
    
      // sessions list (flatten)
// Nutzer-Mapping vorbereiten
const allUsers = await idbGetAll(DB, 'users');
const userMap = {};
for (const u of allUsers) userMap[u.username] = u.displayName;

// Sessions aufbereiten
const all = [];
for (const c of cats) {
  const vis = await filterSessionsForViewer(c, c.sessions || []);
  vis.forEach(s =>
    all.push({
      cat: c.name,
      dur: s.durationMin,
      note: s.note,
      user: userMap[s.username] || s.username
    })
  );
}

// Tabelle ausgeben
sessionsTable.innerHTML = all
  .map(
    s => `<tr>
      <td>${escapeHtml(s.user || '')}</td>
      <td>${escapeHtml(s.cat)}</td>
      <td>${minutesToHuman(s.dur)}</td>
      <td>${escapeHtml(s.note || '')}</td>
    </tr>`
  )
  .join('');

    
      drawBarChart(); drawLineChart();
    }
    
 // ---------------------------
// Echte BarChart-Daten
// ---------------------------
function drawBarChart(){
  const ctx = document.getElementById('barChart');
  if(!ctx || !STATE.currentUser) return;

  idbGetAll(DB,'categories').then(async cats=>{
    const currentUser = await idbGet(DB, 'users', STATE.currentUser);
    const isAdmin = currentUser && currentUser.role === 'Administrator';
    const data = [];

    for(const cat of cats){
      if(!cat.sessions || cat.sessions.length === 0) continue;

      let sessions = [];
      if(isAdmin) {
        // Admin sieht nur LemGOesHANA
        if (cat.system && cat.name === NON_DELETABLE_CATEGORY_NAME) {
          sessions = cat.sessions;
        }
      } else {
        // User sieht eigene Kategorien + LemGOesHANA
        if (cat.owner === STATE.currentUser || cat.system) {
          sessions = cat.sessions.filter(s => s.username === STATE.currentUser);
        }
      }

      if (sessions.length === 0) continue;

      const totalMin = sessions.reduce((sum,s)=> sum + (s.durationMin||0), 0);
      data.push({ name: cat.name, totalMin });
    }

    // Falls keine Daten vorhanden
    const c = ctx.getContext('2d');
    c.clearRect(0,0,ctx.width,ctx.height);
    if(data.length === 0){
      c.font = '16px sans-serif';
      c.fillStyle = '#888';
      c.fillText('Keine Daten vorhanden', 20, 30);
      return;
    }

    // Zeichnung vorbereiten
    const margin = 40;
    const w = ctx.width - margin*2;
    const h = ctx.height - margin*2;
    const maxVal = Math.max(...data.map(d=>d.totalMin));
    const barWidth = w / data.length * 0.6;
    const step = w / data.length;

    // Achsen
    c.strokeStyle = '#ccc';
    c.lineWidth = 1;
    c.beginPath();
    c.moveTo(margin, margin);
    c.lineTo(margin, margin + h);
    c.lineTo(margin + w, margin + h);
    c.stroke();

    // Balken
    c.fillStyle = '#2563eb';
    data.forEach((d,i)=>{
      const x = margin + i * step + step * 0.2;
      const y = margin + h - (d.totalMin / maxVal) * h;
      const barH = (d.totalMin / maxVal) * h;
      c.fillRect(x, y, barWidth, barH);

      // Wert anzeigen
      c.fillStyle = '#333';
      c.font = '11px sans-serif';
      c.textAlign = 'center';
      c.fillText(`${Math.round(d.totalMin)}m`, x + barWidth/2, y - 4);
      c.fillStyle = '#2563eb';
    });

    // Kategorien-Beschriftung
    c.fillStyle = '#444';
    c.font = '11px sans-serif';
    c.textAlign = 'center';
    data.forEach((d,i)=>{
      const x = margin + i * step + step * 0.2 + barWidth/2;
      const y = margin + h + 14;
      c.fillText(d.name, x, y);
    });

    // Titel
    c.fillStyle = '#444';
    c.font = '13px sans-serif';
    c.textAlign = 'left';
    c.fillText('Zeit pro Kategorie (Minuten)', margin, margin - 10);
  });
}


    function roundRect(ctx,x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); }
    function getCssVar(name){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim() || '#fff'; }
    
// ---------------------------
// Echte LineChart-Daten
// ---------------------------
function drawLineChart(){
  const ctx = document.getElementById('lineChart');
  if(!ctx || !STATE.currentUser) return;

  // Hole alle Kategorien des aktuellen Benutzers
  idbGetAll(DB,'categories').then(cats=>{
    // Sessions dieses Users (und ggf. LemGOesHANA) einsammeln
    const sessions = [];
    cats.forEach(cat=>{
      if(cat.system && STATE.currentUser !== 'admin') return; // Nur Admin sieht alle Systemdaten
      if(cat.sessions){
        for(const s of cat.sessions){
          if(s.username === STATE.currentUser || STATE.currentUser === 'admin'){
            sessions.push({
              category: cat.name,
              durationMin: s.durationMin || 0,
              timestamp: s.timestamp || Date.now()
            });
          }
        }
      }
    });

    if(sessions.length === 0){
      const c = ctx.getContext('2d');
      c.clearRect(0,0,ctx.width,ctx.height);
      c.font = '16px sans-serif';
      c.fillStyle = '#888';
      c.fillText('Keine Daten vorhanden', 20, 30);
      return;
    }

    // Gruppiere nach Datum
    const dailyTotals = {};
    for(const s of sessions){
      const date = new Date(s.timestamp);
      const key = date.toISOString().substring(0,10);
      dailyTotals[key] = (dailyTotals[key] || 0) + s.durationMin;
    }

    // Sortiere chronologisch
    const dates = Object.keys(dailyTotals).sort();
    const values = dates.map(d=> dailyTotals[d]);

    // Canvas vorbereiten
    const c = ctx.getContext('2d');
    c.clearRect(0,0,ctx.width,ctx.height);

    // Achsen / Linien
    const margin = 40;
    const w = ctx.width - margin*2;
    const h = ctx.height - margin*2;
    const maxVal = Math.max(...values);
    const yScale = maxVal>0 ? h/maxVal : 1;
    const xStep = w / Math.max(1, dates.length-1);

    // Achsen zeichnen
    c.strokeStyle = '#ccc';
    c.lineWidth = 1;
    c.beginPath();
    c.moveTo(margin, margin);
    c.lineTo(margin, margin+h);
    c.lineTo(margin+w, margin+h);
    c.stroke();

    // Datenlinie
    c.strokeStyle = '#4f46e5';
    c.lineWidth = 2;
    c.beginPath();
    values.forEach((v,i)=>{
      const x = margin + i*xStep;
      const y = margin + h - v*yScale;
      if(i===0) c.moveTo(x,y); else c.lineTo(x,y);
    });
    c.stroke();

    // Punkte
    c.fillStyle = '#4f46e5';
    values.forEach((v,i)=>{
      const x = margin + i*xStep;
      const y = margin + h - v*yScale;
      c.beginPath();
      c.arc(x, y, 3, 0, 2*Math.PI);
      c.fill();
    });

    // Achsenbeschriftung (Datum unten)
    c.fillStyle = '#666';
    c.font = '11px sans-serif';
    dates.forEach((d,i)=>{
      const x = margin + i*xStep - 15;
      const y = margin + h + 15;
      c.fillText(d.slice(5), x, y);
    });

    // Titel / Einheiten
    c.fillStyle = '#444';
    c.font = '13px sans-serif';
    c.fillText('T√§gliche Gesamtzeit (min)', margin, margin - 10);
  });
}

    
    // ---------------------------
    // Modals
    // ---------------------------
    function openModal(innerHTML){
      closeModal();
      const backdrop = document.createElement('div'); backdrop.className='modal-backdrop';
      const modal = document.createElement('div'); modal.className='modal';
      modal.innerHTML = innerHTML + `<div style="text-align:right;margin-top:8px"><button id="closeModal" class="small">Schlie√üen</button></div>`;
      backdrop.appendChild(modal); document.getElementById('modalRoot').appendChild(backdrop);
      backdrop.querySelector('#closeModal').onclick = ()=> closeModal();
      return modal;
    }
    function closeModal(){ const root=document.getElementById('modalRoot'); root.innerHTML=''; }
    
    // ---------------------------
    // startup + Auto-Login (Variante 2)
    // ---------------------------
    init();
    window.addEventListener('DOMContentLoaded', async ()=>{
      const lastUser = localStorage.getItem('zm_lastUser');
      if(lastUser){
        const user = await idbGet(DB,'users',lastUser);
        if(user){
          STATE.currentUser = user.username;
          document.getElementById('greeting').textContent = 'Hallo ' + user.displayName + ' üëã';
          document.getElementById('logoutBtn').style.display='inline-block';
          if(user.pwExpired){
            renderChangePassword(true);
          } else {
            renderDashboard();
          }
        }
      }
    });
    
    // ---------------------------
    // Timer abdocken / Mini-Fenster (Popup mit Theme & Kategorien)
   // ---------------------------
// Timer abdocken / Mini-Fenster (finale stabile Version)
// ---------------------------
let miniWin = null;

async function openMiniTimerWindow() {
  // Wenn bereits offen, fokussieren
  if (miniWin && !miniWin.closed) {
    miniWin.focus();
    return;
  }

  const features = "width=320,height=220,resizable=no,scrollbars=no";
  miniWin = window.open("", "miniTimer", features);

  if (!miniWin) {
    alert("Popup blockiert. Bitte Popups erlauben.");
    return;
  }

  // Theme √ºbernehmen
  const isDark = document.documentElement.classList.contains("dark");

  // HTML + Styles schreiben
  miniWin.document.open();
  miniWin.document.write(`<!doctype html>
    <html>
      <head>
        <meta charset="utf-8">
        <title>Timer</title>
        <style>
          :root {
            --bg: #f3f4f6; --text: #0b1220; --panel: #ffffff;
            --muted: #425066; --ok: #28a745; --err: #ff4d4f;
          }
          :root.dark {
            --bg: #0b0b0c; --text: #e8e8e8; --panel: #0f1112;
            --muted: #9aa0a6;
          }
          body {
            font-family: system-ui, Segoe UI, Roboto, Arial;
            background: var(--bg); color: var(--text);
            margin: 0; padding: 14px;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
          }
          #time { font-size: 2rem; font-weight: bold; margin: 10px 0; }
          select, button {
            padding: 6px 10px; border-radius: 6px; font-size: 0.95rem;
          }
          select {
            width: 100%; margin-bottom: 10px;
            background: var(--panel); color: var(--text);
            border: 1px solid rgba(0,0,0,0.15);
          }
          button {
            cursor: pointer; border: none;
            margin: 2px; color: #fff;
          }
          .start { background: var(--ok); }
          .stop { background: var(--err); }
          #status { font-size: 0.9rem; color: var(--muted); }
        </style>
      </head>
      <body>
        <select id="catSelect"></select>
        <div id="status">Gestoppt</div>
        <div id="time">--:--:--</div>
        <div>
          <button id="startBtn" class="start">Start</button>
          <button id="stopBtn" class="stop">Stop</button>
        </div>
      </body>
    </html>`);
  miniWin.document.close();

  // Theme √ºbernehmen
  miniWin.document.documentElement.classList.toggle("dark", isDark);

  // Inhalt erst nach vollst√§ndigem Laden ansprechen
  miniWin.addEventListener(
    "load",
    async () => {
      try {
        // üîπ Datenbank sicher √∂ffnen
        if (!DB) DB = await openDB("zm_db", 1);

        // üîπ Benutzer & Rollen abfragen
        const user = await idbGet(DB, "users", STATE.currentUser);
        const isAdmin = user && user.role === "Administrator";

        // üîπ Kategorien laden und Dropdown f√ºllen
        const cats = await idbGetAll(DB, "categories");
        const sel = miniWin.document.getElementById("catSelect");
        cats
          .filter((c) => {
            if (isAdmin) return c.name === NON_DELETABLE_CATEGORY_NAME;
            return (
              c.owner === STATE.currentUser ||
              c.name === NON_DELETABLE_CATEGORY_NAME
            );
          })
          .forEach((c) => {
            const opt = miniWin.document.createElement("option");
            opt.value = c.id;
            opt.textContent = c.name;
            sel.appendChild(opt);
          });

        // üü¢ Timer starten
        miniWin.document.getElementById("startBtn").addEventListener("click", () => {
          const chosen = sel.value;
          if (!chosen) {
            alert("Bitte eine Kategorie ausw√§hlen.");
            return;
          }
          const active = JSON.parse(localStorage.getItem("zm_active") || "null");
          if (active && active.username === STATE.currentUser) {
            alert("Es l√§uft bereits ein Timer.");
            return;
          }
          const entry = {
            id: uid(),
            username: STATE.currentUser,
            start: Date.now(),
            durationMin: null,
            note: "",
            categoryId: chosen,
          };
          localStorage.setItem("zm_active", JSON.stringify(entry));
          showToast("Timer gestartet");
        });

        // üî¥ Timer stoppen mit Notiz
        miniWin.document.getElementById("stopBtn").addEventListener("click", async () => {
          if (!DB) DB = await openDB("zm_db", 1);
          const raw = localStorage.getItem("zm_active");
          if (!raw) {
            alert("Kein laufender Timer.");
            return;
          }
          const a = JSON.parse(raw);
          if (a.username !== STATE.currentUser) {
            alert("Dieser Timer geh√∂rt einem anderen Benutzer.");
            return;
          }
          const durMin = Math.max(1, Math.round((Date.now() - a.start) / 60000));
          const note = miniWin.prompt("Kurze Beschreibung (optional):") || "";
          const catId = sel.value || a.categoryId;
          const cat = await idbGet(DB, "categories", catId);
          if (!cat) {
            alert("Kategorie nicht gefunden.");
            localStorage.removeItem("zm_active");
            return;
          }
          cat.sessions = cat.sessions || [];
          cat.sessions.push({
            id: a.id,
            username: a.username,
            durationMin: durMin,
            note,
          });
          await idbPut(DB, "categories", cat);
          localStorage.removeItem("zm_active");
          showToast("Zeit gestoppt ‚úì");
          renderDashboard();
          await saveSessionToCloud({
  id: a.id,
  username: a.username,
  category: cat.name,
  durationMin: durMin,
  note,
});
        });

        // üîÅ Live-Update der Anzeige im Popup
        const statusEl = miniWin.document.getElementById("status");
        const timeEl = miniWin.document.getElementById("time");
        const ticker = setInterval(() => {
          if (!miniWin || miniWin.closed) {
            clearInterval(ticker);
            miniWin = null;
            return;
          }
          const raw = localStorage.getItem("zm_active");
          let text = "--:--:--";
          if (raw) {
            try {
              const a = JSON.parse(raw);
              if (a.username === STATE.currentUser) {
                text = msToHms(Date.now() - a.start);
                statusEl.textContent = "L√§uft";
              } else {
                statusEl.textContent = "Gestoppt";
              }
            } catch {
              text = "--:--:--";
              statusEl.textContent = "Fehler";
            }
          } else {
            statusEl.textContent = "Gestoppt";
          }
          timeEl.textContent = text;
        }, 500);
      } catch (err) {
        console.error("MiniTimer Fehler:", err);
      }
    },
    { once: true }
  );
}

    
    // ---------------------------
    // helpers (CSV/html already above)
    // ---------------------------
    // ---------------------------
// Admin-Tools: Passwort-Reset & neuen Benutzer hinzuf√ºgen
// ---------------------------

// Einzelnes Benutzerpasswort auf Initialwert zur√ºcksetzen
async function resetUserPassword() {
  const allUsers = await idbGetAll(DB, 'users');
  if (!allUsers || allUsers.length === 0) {
    alert('Keine Benutzer gefunden.');
    return;
  }

  const usernames = allUsers.map(u => u.username);
  const name = prompt(
    `Welches Benutzerkonto soll zur√ºckgesetzt werden?\n\nVerf√ºgbare Benutzer:\n${usernames.join(', ')}`
  );
  if (!name) return;

  const user = allUsers.find(u => u.username === name.trim());
  if (!user) {
    alert('Benutzer nicht gefunden.');
    return;
  }

  const confirmReset = confirm(
    `Passwort von "${user.displayName}" (${user.username}) auf das Initialpasswort "Stadtwerke1" zur√ºcksetzen?`
  );
  if (!confirmReset) return;

  user.password = 'Stadtwerke1';
  user.pwExpired = true;
  await idbPut(DB, 'users', user);
  showToast(`Passwort f√ºr ${user.displayName} wurde zur√ºckgesetzt.`);
}

// Neuen Benutzer hinzuf√ºgen
async function addNewUser() {
  const username = prompt('Benutzername (Login-Name, klein geschrieben):');
  if (!username) return;

  const existing = await idbGet(DB, 'users', username);
  if (existing) {
    alert('Dieser Benutzername existiert bereits.');
    return;
  }

  const displayName = prompt('Anzeigename (z. B. "Max Mustermann"):') || username;
  const role = confirm('Soll der Benutzer Administratorrechte haben?')
    ? 'Administrator'
    : 'User';

  const newUser = {
    username,
    password: 'Stadtwerke1',
    displayName,
    role,
    pwExpired: true
  };

  await idbPut(DB, 'users', newUser);
  showToast(`Neuer Benutzer "${displayName}" angelegt (Initialpasswort: Stadtwerke1).`);
}
// ---------------------------
// Admin: Benutzerverwaltung (Dropdown + Reset/Add)
// ---------------------------

// Dropdown mit Benutzern bef√ºllen
async function populateUserDropdown() {
  const users = await idbGetAll(DB, 'users');
  const sel = document.getElementById('userSelect');
  if (!sel) return;
  sel.innerHTML = users
    .map(u => `<option value="${u.username}">${u.displayName} (${u.username})</option>`)
    .join('');
}

// Passwort eines ausgew√§hlten Benutzers zur√ºcksetzen
async function resetUserPassword(username) {
  const user = await idbGet(DB, 'users', username);
  if (!user) {
    alert('Benutzer nicht gefunden.');
    return;
  }

  const confirmReset = confirm(
    `Passwort von "${user.displayName}" (${user.username}) auf das Initialpasswort "Stadtwerke1" zur√ºcksetzen?`
  );
  if (!confirmReset) return;

  user.password = 'Stadtwerke1';
  user.pwExpired = true;
  await idbPut(DB, 'users', user);
  showToast(`Passwort f√ºr ${user.displayName} wurde zur√ºckgesetzt.`);
}

// Neuen Benutzer hinzuf√ºgen
async function addNewUser() {
  const username = prompt('Benutzername (Login-Name, klein geschrieben):');
  if (!username) return;

  const existing = await idbGet(DB, 'users', username);
  if (existing) {
    alert('Dieser Benutzername existiert bereits.');
    return;
  }

  const displayName = prompt('Anzeigename (z. B. "Max Mustermann"):') || username;
  const role = confirm('Soll der Benutzer Administratorrechte haben?')
    ? 'Administrator'
    : 'User';

  const newUser = {
    username,
    password: 'Stadtwerke1',
    displayName,
    role,
    pwExpired: true
  };

  await idbPut(DB, 'users', newUser);
  await populateUserDropdown(); // Dropdown direkt aktualisieren
  showToast(`Benutzer "${displayName}" wurde angelegt (Initialpasswort: Stadtwerke1).`);
}

    // Done.
    </script>
    
</body>
</html>
